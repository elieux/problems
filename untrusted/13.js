/*
 * robotMaze.js
 *
 * The blue key is inside a labyrinth, and extracting
 * it will not be easy.
 *
 * It's a good thing that you're a AI expert, or
 * we would have to leave empty-handed.
 */

function startLevel(map) {
    // Hint: you can press R or 5 to "rest" and not move the
    // player, while the robot moves around.

    map.getRandomInt = function(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    map.placePlayer(map.getWidth()-1, map.getHeight()-1);
    var player = map.getPlayer();

    map.defineObject('robot', {
        'type': 'dynamic',
        'symbol': 'R',
        'color': 'gray',
        'onCollision': function (player, me) {
            me.giveItemTo(player, 'blueKey');
        },
        'behavior': function (me) {

            // move randomly
            // var moves = map.getAdjacentEmptyCells(me.getX(), me.getY());
            // getAdjacentEmptyCells gives array of ((x, y), direction) pairs
            // me.move(moves[map.getRandomInt(0, moves.length - 1)][1]);

            var meX = me.getX();
            var meY = me.getY();

            var keyX = map.getWidth() - 2;
            var keyY = 8;

            if (keyX == meX && keyY - 1 <= meY) {
                me.move('down');
                return;
            }

            var i;

            var width = map.getWidth();
            var height = 10;

            var minimap = [];
            for (i = 0; i < width; ++i) {
                minimap.push(new Array(height));
            }

            var visited = function (pos) {
                return undefined !== minimap[pos[0]][pos[1]];
            };

            var steps = function (pos) {
                return minimap[pos[0]][pos[1]][2];
            };

            var visit = function (nxt, cur, dir) {
                if (visited(nxt) && steps(nxt) <= steps(cur) + 1) {
                    return;
                }

                minimap[nxt[0]][nxt[1]] = [
                    cur[0], cur[1], steps(cur) + 1, dir
                ];
            };

            var pred = function (cur) {
                return minimap[cur[0]][cur[1]];
            };

            var queue, cur, nxt, moves;

            queue = [];
            queue.push([ meX, meY ]);
            minimap[meX][meY] = [ undefined, undefined, 0 ];

            while (queue.length > 0) {
                cur = queue.pop();
                moves = map.getAdjacentEmptyCells(cur[0], cur[1]);

                moves.forEach(function (move) {
                    nxt = move[0];
                    if (!visited(nxt)) {
                        queue.push(nxt);
                    }
                    visit(nxt, cur, move[1]);
                });
            }

            nxt = [ keyX , keyY - 1 ];
            do {
                cur = pred(nxt);
                if (cur[0] == meX && cur[1] == meY) {
                    break;
                }

                nxt = cur;
            } while (true);

            me.move(cur[3]);

        }
    });

    map.defineObject('barrier', {
        'symbol': 'â–‘',
        'color': 'purple',
        'impassable': true,
        'passableFor': ['robot']
    });

    map.placeObject(0, map.getHeight() - 1, 'exit');
    map.placeObject(1, 1, 'robot');
    map.placeObject(map.getWidth() - 2, 8, 'blueKey');
    map.placeObject(map.getWidth() - 2, 9, 'barrier');

    var autoGeneratedMaze = new ROT.Map.DividedMaze(map.getWidth(), 10);
    autoGeneratedMaze.create( function (x, y, mapValue) {
        // don't write maze over robot or barrier
        if ((x == 1 && y == 1) || (x == map.getWidth() - 2 && y >= 8)) {
            return 0;
        } else if (mapValue === 1) { //0 is empty space 1 is wall
            map.placeObject(x,y, 'block');
        } else {
            map.placeObject(x,y,'empty');
        }
    });
}

function validateLevel(map) {
    map.validateExactlyXManyObjects(1, 'exit');
    map.validateExactlyXManyObjects(1, 'robot');
    map.validateAtMostXObjects(1, 'blueKey');
}

function onExit(map) {
    if (!map.getPlayer().hasItem('blueKey')) {
        map.writeStatus("We need to get that key!");
        return false;
    } else {
        return true;
    }
}
